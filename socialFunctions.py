# -*- coding: utf-8 -*-
"""scoial.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uTVX7i2Wj7J1KBAcQUVXQW6SBeZAV5Ex
"""

from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from tkinter import ttk, filedialog, messagebox
import tkinter as tk
import pandas as pd
import networkx as nx
# import matplotlib.colors as mcolors
import numpy as np
import matplotlib.pyplot as plt
from networkx.algorithms import community
from networkx.algorithms.community import girvan_newman

"""#main"""


def create_graph_from_csv(node_csv_file, edge_csv_file, directed=False):
    """
    Create a graph from CSV files containing node and edge data.

    Parameters:
    - node_csv_file (str): Path to the CSV file containing node data.
    - edge_csv_file (str): Path to the CSV file containing edge data.
    - directed (bool, optional): If True, creates a directed graph (DiGraph),
      otherwise creates an undirected graph (Graph). Default is False.

    Returns:
    - G (networkx.Graph or networkx.DiGraph): The constructed graph.
    """
    # Load data
    nodes_df = pd.read_csv(node_csv_file)
    edges_df = pd.read_csv(edge_csv_file)

    # Create graph
    if directed:
        G = nx.DiGraph()
    else:
        G = nx.Graph()

    # Add nodes
    for idx, row in nodes_df.iterrows():
        G.add_node(row['ID'], **row.drop('ID').to_dict())

    # Add edges
    for idx, row in edges_df.iterrows():
        G.add_edge(row['Source'], row['Target'], **
                   row.drop(['Source', 'Target']).to_dict())

    return G, nodes_df, edges_df
    pass

# Example usage:
# G = create_graph_from_csv('/content/Nodes.csv', '/content/Edges.csv', directed=True)
#G = create_graph_from_csv('/content/Nodes.csv', '/content/Edges.csv', directed=False)
#G,nodes_df,edges_df= create_graph_from_csv('Nodes.csv', 'Edges.csv', directed=False)


def draw_graph(G):
  nx.draw(G, with_labels=True, node_color='skyblue')
  plt.show()
  pass

# draw_graph(G)


"""# Task 1"""


def set_new_attributes(G, newColor, newSize):
 node_sizes = [G.nodes[node].get('size', newSize) for node in G]
 node_colors = set([G.nodes[node].get('color', newColor) for node in G])
 return node_sizes, node_colors
 pass
# node_shapes = set([G.nodes[node].get('shape', 'o') for node in G])  # only 'o, cmap_name='Dark2'' is supported directly in nx.draw

# Edge attributes for drawing


def set_edge_attributes(G, newColor, thickness):
 edge_colors = [G.edges[edge].get('color', newColor) for edge in G.edges()]
 edge_widths = [G.edges[edge].get('thickness', thickness)
                                  for edge in G.edges()]
 return edge_colors, edge_widths
 pass
# trail
# edge_colors ,edge_widths = set_edge_attributes ('gray',1)
# node_sizes ,node_colors = set_new_attributes("blue", 100)

# pos = nx.spring_layout(G)
# Drawing nodes and edges
# nx.draw_networkx_edges(G, pos, width=edge_widths, edge_color=edge_colors)
# nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color=node_colors, alpha=0.9)
# nx.draw_networkx_labels(G, pos)

# plt.title('Customized Network Graph')
# plt.show()


"""Colored Graph """


def create_colored_graph(node_df, edge_df, directed=True):
    if directed:
        G = nx.DiGraph()
    else:
        G = nx.Graph()

    unique_classes = node_df['Class'].unique()
    class_colors = dict(
        zip(unique_classes, plt.cm.tab10.colors[:len(unique_classes)]))

    for idx, row in node_df.iterrows():
        G.add_node(row['ID'], **row.drop('ID').to_dict(),
                   color=class_colors.get(row['Class'], 'gray'))

    for idx, row in edge_df.iterrows():
        G.add_edge(row['Source'], row['Target'], **
                   row.drop(['Source', 'Target']).to_dict())

    return G, class_colors
    pass


def plot_class_histogram(class_counts, class_colors):
    plt.figure(figsize=(8, 6))
    plt.bar(range(len(class_counts)), class_counts.values, color=[
            class_colors.get(cls, 'gray') for cls in class_counts.index])
    plt.xticks(range(len(class_counts)), class_counts.index)
    plt.xlabel('Class')
    plt.ylabel('Count')
    plt.title('Class Distribution')
    plt.show()
    pass


def draw_colored_graph(G, directed=True):
    pos = nx.spring_layout(G)  # Define the layout for better visualization
    node_colors = [data['color'] for node, data in G.nodes(data=True)]
    if directed:
        nx.draw(G, pos, node_color=node_colors, with_labels=True, arrows=True)
    else:
        nx.draw(G, pos, node_color=node_colors, with_labels=True)
    plt.show()
    pass

# Example usage:
# directed_G, class_colors = create_colored_graph(nodes_df, edges_df, directed=True)
# draw_colored_graph(directed_G, directed=True)

# undirected_G, class_colors = create_colored_graph(nodes_df, edges_df, directed=False)
# draw_colored_graph(undirected_G, directed=False)


"""# task 2"""
def visualize_graph_with_layout(G, layout_algorithm='spring'):
    """
    Visualizes the given graph with the specified layout algorithm.

    Parameters:
        G (NetworkX graph): The input graph.
        layout_algorithm (str): The layout algorithm to use. Possible values:
                                'spring', 'random', 'shell', 'circular',
                                'spectral', 'kamada_kawai',
                                'fruchterman_reingold', 'spiral', 'tree', 'radial'.
                                Default is 'spring'.

    Returns:
        None
    """
    # Compute the layout
    if layout_algorithm == 'spring':
        pos = nx.spring_layout(G)
    elif layout_algorithm == 'random':
        pos = nx.random_layout(G)
    elif layout_algorithm == 'shell':
        pos = nx.shell_layout(G)
    elif layout_algorithm == 'circular':
        pos = nx.circular_layout(G)
    elif layout_algorithm == 'spectral':
        pos = nx.spectral_layout(G)
    elif layout_algorithm == 'kamada_kawai':
        pos = nx.kamada_kawai_layout(G)
    elif layout_algorithm == 'fruchterman_reingold':
        pos = nx.fruchterman_reingold_layout(G)
    elif layout_algorithm == 'spiral':
        pos = nx.spiral_layout(G)
        # hierarchical layouts
    # elif layout_algorithm == 'tree':
     #   pos = tree_layout(G)
    elif layout_algorithm == 'radial':
        pos = radial_layout(G)
    else:
        raise ValueError(
            "Invalid layout algorithm. Please choose from the available options.")

    # Draw the graph
    nx.draw(G, pos, with_labels=True,node_color='skyblue')
    plt.title(
        f"Graph Visualization with {layout_algorithm.capitalize()} Layout")
   # plt.show()
    pass


def radial_layout(G):
    """
    Computes a radial layout for the given graph.

    Parameters:
        G (NetworkX graph): The input graph.

    Returns:
        pos (dict): A dictionary containing node positions for the radial layout.
    """
    pos = nx.circular_layout(G)  # Circular layout
    radii = [pos[node][0]
        for node in G.nodes()]  # Extract x-coordinates as radii
    max_radius = max(radii)
    for node in G.nodes():
        pos[node] = (pos[node][0] / max_radius,
                     pos[node][1])  # Normalize radii
    return pos
    pass


def tree_layout(G, root=None):
    """
    Computes a tree layout for the given graph using Breadth-First Search (BFS).

    Parameters:
        G (NetworkX graph): The input graph.
        root: The root node for the BFS traversal. If not specified, the first node encountered will be used.

    Returns:
        pos (dict): A dictionary containing node positions for the tree layout.
    """
    if root is None:
        root = next(iter(G))
    pos = {root: (0, 0)}  # Set the position of the root node
    queue = [(root, None)]  # Initialize the BFS queue with the root node
    level = {root: 0}  # Track the level of each node in the BFS tree

    while queue:
        node, parent = queue.pop(0)  # Dequeue node from the queue
        children = [child for child in G.neighbors(
            node) if child != parent]  # Exclude the parent node
        for i, child in enumerate(children):
            pos[child] = (pos[node][0] + i - len(children) / 2, -level[node] - 1)  # Compute position
            queue.append((child, node))  # Enqueue child node
            level[child] = level[node] + 1  # Increment level
    return pos
    pass
# Example usage:
# visualize_graph_with_layout(G, layout_algorithm='radial')


"""# Task 3"""

def compute_graph_metrics(G, directed=False):
    """
    Computes and prints various graph metrics.

    Parameters:
        G (NetworkX graph): The input graph.
        directed (bool, optional): Whether the graph is directed. Default is False.

    Returns:
        None
    """
    plt.figure(figsize=(10, 5))
    colors = ['blue', 'red', 'green', 'orange', 'purple']
    labels = ['Degree Distribution', 'Degree Centrality', 'Closeness Centrality',
              'Betweenness Centrality']
    if directed:
        labels.append('Katz Centrality')
    else:
        labels.append('Eigenvector Centrality')
    
    # Degree distribution
    plt.subplot(3, 2, 1)
    plt.hist([v for k, v in nx.degree(G)], bins=15, rwidth=0.8, color=colors[0])
    plt.title(labels[0])
    plt.xlabel('Degree')
    plt.ylabel('Frequency')

    # Centrality distributions
    for i, metric in enumerate(labels[1:], start=2):
        plt.subplot(3, 2, i)
        if metric == 'Degree Centrality':
            values = list(nx.centrality.degree_centrality(G).values())
        elif metric == 'Katz Centrality':
            values = list(nx.katz_centrality(G).values())
        elif metric == 'Eigenvector Centrality':
            values = list(nx.eigenvector_centrality(G).values()) if not directed else []
        else:
            values = list(nx.centrality.closeness_centrality(G).values()) if metric == "Closeness Centrality" else list(nx.centrality.betweenness_centrality(G).values())
        plt.hist(values, bins=15, alpha=0.5, color=colors[i-1])
        plt.title(metric)
        plt.xlabel('Centrality Score')
        plt.ylabel('Frequency')

    plt.tight_layout()
    pass
def compute_graph_statistics(G, directed=False):
    # Other metrics
    clustering_coefficient = nx.average_clustering(G)
    message = f"Average Clustering Coefficient: {clustering_coefficient}"
    # to handle the error
    if directed == True and not nx.is_strongly_connected(G):
      # message += "Graph is not strongly connected. Cannot compute average shortest path length."
        messagebox.showinfo("Directed graph error","Graph is not strongly connected. Cannot compute average shortest path length.")
    else:
      average_path_length = nx.average_shortest_path_length(G)
      message += f"\nAverage Path Length: {average_path_length}"

    # Summary statistics
    degree_sequence = sorted([d for n, d in G.degree()], reverse=True)
    mean_degree = np.mean(degree_sequence)
    median_degree = np.median(degree_sequence)
    std_dev_degree = np.std(degree_sequence)
    message += f"\nMean Degree: {mean_degree}"
    message += f"\nMedian Degree: {median_degree}"
    message += f"\nStandard Deviation of Degree: {std_dev_degree}"
    return message
    pass
# Example usage:
# compute_graph_metrics(G, directed=False)
# compute_graph_statistics(G, directed=False)

"""# Task 4"""

"""**filter #1 Filtering nodes based on centrality measures**"""


def filter_nodes_by_centrality(G, centrality_type='degree', centrality_threshold=0.1):
    """
    Filter nodes based on centrality measures.

    Parameters:
        G (NetworkX graph): The input graph.
        centrality_type (str): Type of centrality measure ('degree', 'betweenness', 'closeness', 'eigenvector').
        centrality_threshold (float): Threshold value for centrality filtering.
                                      Nodes with centrality greater than or equal
                                      to this threshold will be kept.

    Returns:
        G_filtered (NetworkX graph): Filtered graph containing only nodes with centrality
                                     greater than or equal to the threshold.
    """
    # Select the appropriate centrality calculation
    if centrality_type == 'degree':
        centrality_values = nx.degree_centrality(G)
    elif centrality_type == 'betweenness':
        centrality_values = nx.betweenness_centrality(G)
    elif centrality_type == 'closeness':
        centrality_values = nx.closeness_centrality(G)
    elif centrality_type == 'eigenvector':
        centrality_values = nx.eigenvector_centrality(G, max_iter=1000)
    else:
        raise ValueError(
            "Unsupported centrality type. Choose from 'degree', 'betweenness', 'closeness', 'eigenvector'.")

    # Filter nodes based on centrality threshold
    nodes_to_keep = [node for node, centrality in centrality_values.items() if centrality >= centrality_threshold]
    # Create a copy of the subgraph to operate independently of the original graph
    G_filtered = G.subgraph(nodes_to_keep).copy()
    nx.draw(G_filtered, with_labels=True, node_color='skyblue')
    return G_filtered
    #plt.show()
    pass
# Example usage
#G,_,_ = create_graph_from_csv('Nodes.csv', 'Edges.csv', directed=False)
#filter_nodes_by_centrality(G, 'betweenness')

# print("Nodes filtered by degree centrality:", filtered_graph_degree.number_of_nodes())
# print("Nodes filtered by betweenness centrality:", filtered_graph_betweenness.number_of_nodes())


""" **filter #2 filtering nodes based on their membership** """


def filter_nodes(G, community=None, centrality_measure=None, min_value=None, max_value=None):

    # Compute centrality scores
    if centrality_measure:
        if centrality_measure == 'degree':
            centrality_scores = nx.degree_centrality(G)
        elif centrality_measure == 'betweenness':
            centrality_scores = nx.betweenness_centrality(G)
        elif centrality_measure == 'closeness':
            centrality_scores = nx.closeness_centrality(G)
        #elif centrality_measure == 'eigenvector':
         #   centrality_scores = nx.eigenvector_centrality(G)
        else:
            raise ValueError(
                "Invalid centrality measure. Please choose from 'degree', 'betweenness', 'closeness', or 'eigenvector'.")

        # Filter nodes based on centrality scores falling within certain ranges
        if min_value is not None and max_value is not None:
            filtered_nodes = [node for node, centrality in centrality_scores.items(
            ) if min_value <= centrality <= max_value]
        elif min_value is not None:
            filtered_nodes = [
                node for node, centrality in centrality_scores.items() if centrality >= min_value]
        elif max_value is not None:
            filtered_nodes = [
                node for node, centrality in centrality_scores.items() if centrality <= max_value]
        else:
            filtered_nodes = list(centrality_scores.keys())
    else:
        filtered_nodes = list(G.nodes())

    # Filter nodes based on community membership
    if community is not None:
        community_nodes = [node for node, data in G.nodes(data=True) if data.get(
            'Class') == community and node in filtered_nodes]
    else:
        community_nodes = filtered_nodes

    return community_nodes
    pass


def filter_nodes_by_community(G, community_nodes):
    """
    Filter the graph G to include only nodes belonging to the specified community.

    Args:
    - G: NetworkX graph object
    - community_nodes: List of nodes belonging to the community

    Returns:
    - G_community_filtered: Filtered NetworkX graph object containing only nodes belonging to the community
    """
    G_community_filtered = G.subgraph(community_nodes).copy()
    return G_community_filtered
    pass

# Example usage:
# Call the filter_nodes function to get the community nodes
# community_nodes = filter_nodes(G, community='Teachers')

# Call filter_nodes_by_community to get the filtered graph based on the community nodes
# G_community_filtered = filter_nodes_by_community(G, community_nodes)

# Draw the filtered graph
# nx.draw(G_community_filtered, with_labels=True, node_color='skyblue')
# plt.show()


"""# Task 5"""
def compare_community_detection_algorithms(G):
    # Girvan Newman Algorithm
    gn_communities = tuple(sorted(c) for c in next(girvan_newman(G)))
    gn_num_communities = len(gn_communities)
    gn_modularity = nx.algorithms.community.modularity(G, gn_communities)

    # Louvain Algorithm
    # Check if the graph is undirected
    if not G.is_directed():
        partition = community.label_propagation_communities(G)
        louvain_num_communities = len(partition)
        louvain_modularity = nx.algorithms.community.modularity(G, partition)
    else:
        messagebox.showinfo("Directed graph error","Louvain Algorithm is not implemented for directed graphs.")
        louvain_num_communities = None
        louvain_modularity = None

    # Display comparison
    message="Girvan Newman Algorithm:"
    message+=f"\n Number of Communities:{gn_num_communities}"
    message+=f"\nModularity Score:{gn_modularity}"
    
    message_louvain="Louvain Algorithm:"
    message_louvain+=f"\nNumber of Communities:{louvain_num_communities}"
    message_louvain+=f"\nModularity Score: { louvain_modularity}"
    return message , message_louvain
    pass
# Example usage
# compare_community_detection_algorithms(G)

# G.is_directed()
